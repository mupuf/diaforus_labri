/*
 * reasoning_service.h
 *      Author: maissa
 *      Author: martin <martin.peres@ensi-bourges.fr>
 */

#ifndef REASONING_SERVICE_H_
#define REASONING_SERVICE_H_

#include "pubsub_api.h"
#include "sensors.h"
#include "reasoning_history.h"


/**
 * \brief Proceed to the initialization of the reasoning node
 * \return an error code
 * \retval The subscription ID generated by the reasoning
 */
void reasoning_init ();

/**
 * \brief To be called in the application's Notify callback
 * \return was the subscription meant for the reasoning?
 * \retval 0 it wasn't
 * \retval 1 it was
 */
int reasoning_update(const char * const attributes[], const value_t values[], uint8_t subscriptionId);

/**
 * \brief To be called when an *alarm* must be sent to the operator
 * \param criticality the criticality level of the alarm
 * \param timestamp the timestamp of the alarm
 */
void reasoning_emit_alarm(uint16_t criticality, timestamp_t timestamp, uint32_t involved_sensors);

/* functions that enable or disable notification of corresponding events*/
/**
 * \brief Get the sampling period of the sensors in the area_id
 * \return the sampling rate (> 0)
 * \retval ERROR_VALUE if the area_id isn't the current area_id
 * of the sensor.
 */
int get_sampling_period (int area_id);

/**
 * \brief Set the sampling period of the sensors in the area_id
 * \param area_id the area ID you want the sampling period of
 * \param value the sampling period of the area you want to set
 * \return an error code
 * \retval 0 if the value was correct and stored
 * \retval ERROR_VALUE if the value is not allowed or if the
 * area_id isn't the current area_id of the sensor.
 */
int set_sampling_period (int area_id, int value);

/**
 * \brief Get the alarm criticality threshold.
 * \return the global criticality threshold.
 */
int get_criticality_threshold ();

/**
 * \brief Set the alarm criticality threshold.
 * \return an error code
 * \retval 0 if the value was correct and stored
 * \retval ERROR_VALUE if the value is not allowed
 */
int set_criticality_threshold (int value);

/**
 * \brief Get the criticality level associated with the modality
 * \param modality the modality you want to get the criticality level of
 * \return the criticality level associated with the modality
 * \retval ERROR_VALUE if the modality doesn't exist
 */
int get_modality_criticality (modality_t modality);

/**
 * \brief Get the area criticality level
 * \return the criticality level of the area
 */
uint16_t get_criticality_level ();

/**
 * \brief Get the latency mode associated to this node
 * \return the global latency mode for this node (latency â‚¬ [0;3])
 */
int get_latency_mode();

/**
 * \brief Set the latency mode.
 * \return an error code
 * \retval 0 if the value was correct and stored
 * \retval ERROR_VALUE if the value is not allowed
 */
int set_latency_mode(int mode);

/**
 * \brief Get the time corresponding
 *  to the intrusion duration for this node.
 * \return the average intrusion duration for this node
 */
uint32_t get_max_intrusion_duration();

/**
 * \brief Set the duration corresponding
 *  to the intrusion duration for this node.
 * \return an error code
 * \retval 0 if the value was correct and stored
 * \retval ERROR_VALUE if the value is not allowed
 */
int set_max_intrusion_duration(uint32_t duration);

/**
 * \brief Get the time corresponding
 *  to the intrusion duration for this node.
 * \return the average intrusion duration for this node
 */
uint32_t get_min_intrusion_duration();

/**
 * \brief Set the duration corresponding
 *  to the intrusion duration for this node.
 * \return an error code
 * \retval 0 if the value was correct and stored
 * \retval ERROR_VALUE if the value is not allowed
 */
int set_min_intrusion_duration(uint32_t duration);

#endif /* REASONING_SERVICE_H_ */
